# Technical Context: merged_ric Field Implementation

## Problem Statement

When `speconsense-summarize` performs SNP-based merging of consensus sequences, it accumulates `ric` (Reads in Consensus) values by simple addition. This creates semantic confusion because:

1. **Pre-merge**: `ric=100` means "100 reads were used by SPOA to generate this consensus"
2. **Post-merge**: `ric=180` means "sum of ric values from 3 merged consensuses" - NOT "180 reads used to generate this consensus"

The merged consensus was actually generated by IUPAC-merging pre-existing consensus sequences, not by running SPOA on 180 reads.

### User-Visible Issue

Users noticed that some consensus sequences have `ric` values exceeding `--max-sample-size` (default 500). For example:
- User runs speconsense with `--max-sample-size 500`
- Expects all consensuses to have `ric ≤ 500`
- Finds consensus with `ric=650` in summarize output
- This occurs when speconsense-summarize merges multiple consensuses: `ric=300 + ric=200 + ric=150 = 650`

## Root Cause

### Two-Stage Pipeline Design

Speconsense uses a two-stage design:

1. **speconsense** (core.py): Clustering and initial consensus generation
   - Outputs: `{sample}-all.fasta` with individual cluster consensuses
   - Each consensus has `size` and `ric` fields representing reads used for that consensus
   - Respects `--max-sample-size` limit

2. **speconsense-summarize** (summarize.py): Post-processing and variant management
   - SNP-based merging of similar consensuses (creates IUPAC ambiguity codes)
   - Variant grouping and selection
   - Outputs: Final consensus sequences and FASTQ files

### Where RiC Accumulation Happens

In `summarize.py` around line 1142-1150, during SNP merging:

```python
merged_info = ConsensusInfo(
    sample_name=consensus_i.sample_name,
    cluster_id=consensus_i.cluster_id,
    sequence=best_merge['consensus_sequence'],
    ric=consensus_i.ric + consensus_j.ric,  # Simple addition
    size=best_merge['combined_size'],
    file_path=consensus_i.file_path,
    snp_count=best_merge['snp_count'] if best_merge['snp_count'] > 0 else None,
    primers=consensus_i.primers
)
```

This accumulation is repeated for multi-way merges (if A+B is later merged with C, ric becomes A.ric + B.ric + C.ric).

### Why This Design Exists

SNP merging in `speconsense-summarize` rather than `speconsense` was chosen because:
- Clean separation of concerns: clustering vs variant management
- Allows experimenting with different merge thresholds without re-running expensive clustering
- Natural place for variant selection strategies (size-based, diversity-based)
- Avoids complex intermediate files and multiple consensus regeneration stages

However, it creates the ric accumulation issue.

## Current Behavior

### Header Fields from speconsense (core.py:449)

```
>{sample}-c{num} size={N} ric={N} [median_diff={X}] [p95_diff={X}] [primers={list}]
```

### Header Fields from speconsense-summarize (summarize.py:917, 935)

**Single-cluster consensus:**
```
>{sample}-1 size=100 ric=95 primers=ITS1F,ITS4
```

**Merged consensus (current - problematic):**
```
>{sample}-1 size=180 ric=180 snp=2 primers=ITS1F,ITS4
```

Problem: Cannot distinguish merged from single-cluster consensuses. Users see `ric=180` and assume "high quality single consensus" rather than "3 merged consensuses."

## Proposed Solution

### New Header Field: merged_ric

Add a new field that shows the pre-merge ric values:

**Merged consensus (proposed):**
```
>{sample}-1 size=180 ric=180 merged_ric=100+50+30 snp=2 primers=ITS1F,ITS4
```

**Single-cluster consensus (unchanged):**
```
>{sample}-2 size=100 ric=95 primers=ITS1F,ITS4
```

### Field Semantics

- **`merged_ric=N1+N2+...`** (NEW)
  - List of pre-merge ric values, ordered descending (largest first)
  - Only present when consensus was created by SNP-merging ≥2 clusters
  - Self-contained: no references to transient cluster IDs
  - Count of values indicates number of merged consensuses

- **`ric=N`** (existing, semantics clarified)
  - Total supporting reads available in FASTQ file
  - For single-cluster: reads used for consensus generation
  - For merged: sum of pre-merge ric values (total reads for inspection)

- **`snp=N`** (existing)
  - Number of IUPAC ambiguity positions
  - Only present after SNP merging

### Design Rationale

1. **Self-contained**: No cluster ID references (meaningless on GenBank)
2. **Quality distribution visible**: Shows if ric=180 is from 3×60 (balanced) or 150+20+10 (dominant)
3. **Backward compatible**: Optional field, existing parsers unaffected
4. **Compact**: Single field instead of multiple
5. **Meaningful anywhere**: GenBank curator can interpret without additional context

## Implementation Changes

### 1. Update ConsensusInfo Data Structure (summarize.py:65)

```python
class ConsensusInfo(NamedTuple):
    """Information about a consensus sequence from speconsense output."""
    sample_name: str
    cluster_id: str
    sequence: str
    ric: int
    size: int
    file_path: str
    snp_count: Optional[int] = None
    primers: Optional[List[str]] = None
    merged_ric: Optional[List[int]] = None  # NEW: List of pre-merge ric values
```

### 2. Update Merging Logic (summarize.py:~1142)

```python
# Build merged_ric list - flatten multi-level merges
merged_ric_values = []
for consensus in [consensus_i, consensus_j]:
    if consensus.merged_ric:
        # Already merged - extend with its components
        merged_ric_values.extend(consensus.merged_ric)
    else:
        # Single cluster - add its ric
        merged_ric_values.append(consensus.ric)

# Sort descending to show largest contributor first
merged_ric_values.sort(reverse=True)

merged_info = ConsensusInfo(
    sample_name=consensus_i.sample_name,
    cluster_id=consensus_i.cluster_id,
    sequence=best_merge['consensus_sequence'],
    ric=consensus_i.ric + consensus_j.ric,
    size=best_merge['combined_size'],
    file_path=consensus_i.file_path,
    snp_count=best_merge['snp_count'] if best_merge['snp_count'] > 0 else None,
    primers=consensus_i.primers,
    merged_ric=merged_ric_values  # NEW
)
```

### 3. Update Header Writing (summarize.py:917, 935)

```python
header_parts = [f"size={consensus.size}", f"ric={consensus.ric}"]

# Add merged_ric if present
if consensus.merged_ric:
    merged_str = '+'.join(str(r) for r in consensus.merged_ric)
    header_parts.append(f"merged_ric={merged_str}")

# Add snp if present
if consensus.snp_count is not None and consensus.snp_count > 0:
    header_parts.append(f"snp={consensus.snp_count}")

# Add primers if present
if consensus.primers:
    header_parts.append(f"primers={','.join(consensus.primers)}")

f.write(f">{consensus.sample_name} {' '.join(header_parts)}\n")
```

### 4. Update Header Parsing (summarize.py:127)

```python
def parse_consensus_header(header: str) -> Tuple[Optional[str], Optional[int], Optional[int], Optional[List[str]], Optional[List[int]]]:
    """
    Extract information from Speconsense consensus FASTA header.

    Returns: (sample_name, ric, size, primers, merged_ric)
    """
    sample_match = re.match(r'>([^ ]+) (.+)', header)
    if not sample_match:
        return None, None, None, None, None

    sample_name = sample_match.group(1)
    info_string = sample_match.group(2)

    # Extract RiC value
    ric_match = re.search(r'ric=(\d+)', info_string)
    ric = int(ric_match.group(1)) if ric_match else 0

    # Extract size value
    size_match = re.search(r'size=(\d+)', info_string)
    size = int(size_match.group(1)) if size_match else 0

    # Extract primers value
    primers_match = re.search(r'primers=([^,\s]+(?:,[^,\s]+)*)', info_string)
    primers = primers_match.group(1).split(',') if primers_match else None

    # Extract merged_ric value (NEW)
    merged_ric_match = re.search(r'merged_ric=([\d+]+)', info_string)
    merged_ric = None
    if merged_ric_match:
        merged_ric = [int(x) for x in merged_ric_match.group(1).split('+')]

    return sample_name, ric, size, primers, merged_ric
```

### 5. Update load_consensus_sequences (summarize.py:159)

```python
for record in SeqIO.parse(f, "fasta"):
    sample_name, ric, size, primers, merged_ric = parse_consensus_header(f">{record.description}")

    if sample_name and ric >= min_ric:
        cluster_match = re.search(r'-c(\d+)$', sample_name)
        cluster_id = cluster_match.group(0) if cluster_match else sample_name

        consensus_info = ConsensusInfo(
            sample_name=sample_name,
            cluster_id=cluster_id,
            sequence=str(record.seq),
            ric=ric,
            size=size,
            file_path=fasta_file,
            snp_count=None,
            primers=primers,
            merged_ric=merged_ric  # NEW
        )
```

### 6. Update Variant Renaming (summarize.py:707, 1035)

When renaming variants for output, preserve merged_ric:

```python
renamed_variant = ConsensusInfo(
    sample_name=new_name,
    cluster_id=variant.cluster_id,
    sequence=variant.sequence,
    ric=variant.ric,
    size=variant.size,
    file_path=variant.file_path,
    snp_count=variant.snp_count,
    primers=variant.primers,
    merged_ric=variant.merged_ric  # Preserve
)
```

## Optional Enhancement: Sidecar File for Reconstruction

### Specification

For users who need to reconstruct pre-merge consensuses, generate a sidecar file for each merged consensus.

**File naming**: `{sample_name}-RiC{total}.cluster_sources.tsv`

**Format** (TSV):
```tsv
source_index	ric	size	read_count
1	100	120	120
2	50	55	55
3	30	35	35
```

**Fields:**
- `source_index`: 1-based index matching order in merged_ric field
- `ric`: Pre-merge ric value
- `size`: Pre-merge size value
- `read_count`: Actual reads from this source in FASTQ file

**FASTQ ordering**: Group reads by source_index for easy splitting.

**Generation**: Only create when merged_ric is present and has >1 value.

**Flag**: Add `--write-cluster-sources` option to enable (default: disabled).

### Implementation Location

Add new function in summarize.py:

```python
def write_cluster_sources_file(consensus: ConsensusInfo, fastq_path: str,
                                 merge_traceability: Dict) -> None:
    """Write sidecar TSV showing which reads came from which pre-merge cluster."""
    if not consensus.merged_ric or len(consensus.merged_ric) <= 1:
        return  # Not a merge, skip

    output_path = fastq_path.replace('.fastq', '.cluster_sources.tsv')

    with open(output_path, 'w') as f:
        f.write("source_index\tric\tsize\tread_count\n")

        # Get original cluster names from traceability
        original_names = merge_traceability.get(consensus.sample_name, [])

        for idx, (ric_val, orig_name) in enumerate(zip(consensus.merged_ric, original_names), 1):
            # Look up original size from original consensus files
            # (Would need to track this in merge_traceability)
            size_val = "..."  # Retrieve from traceability
            read_count = "..."  # Count reads in FASTQ section

            f.write(f"{idx}\t{ric_val}\t{size_val}\t{read_count}\n")
```

Call from main output writing logic if flag is enabled.

## Code Locations Reference

### Files to Modify
- `speconsense/summarize.py`

### Key Line Numbers (as of 2025-10-20)
- ConsensusInfo definition: line 65
- parse_consensus_header: line 127
- load_consensus_sequences: line 159
- SNP merging logic: line 1070-1180
- Variant renaming: lines 707, 1035
- Header writing: lines 917, 935

### Functions to Update
1. `parse_consensus_header()` - Add merged_ric parsing
2. `load_consensus_sequences()` - Handle merged_ric from input
3. `perform_snp_merging()` - Build and populate merged_ric during merges
4. `rename_variants_for_output()` - Preserve merged_ric through renaming
5. Header writing in main output functions - Include merged_ric in output

## Testing Considerations

### Test Cases Needed

1. **Single-cluster consensus** - No merged_ric field
2. **Two-way merge** - merged_ric with 2 values
3. **Three-way merge** - merged_ric with 3 values
4. **Multi-level merge** - Flattening behavior (A+B merged with C)
5. **Balanced merge** - Similar ric values (60+55+50)
6. **Dominated merge** - One large, others small (150+20+10)
7. **Round-trip parsing** - Write then parse, verify values preserved
8. **Backward compatibility** - Parsing old files without merged_ric

### Manual Testing

```bash
# Create test data with multiple variants
speconsense-synth reference.fasta -n 300 -e 0.03 -o test.fastq

# Run with SNP merging enabled
speconsense test.fastq --min-size 10
speconsense-summarize --snp-merge-limit 2

# Verify header fields
grep ">" __Summary__/summary.fasta
# Should see merged_ric on some sequences

# Check that merged_ric values sum to ric
# Check that merged_ric is sorted descending
```

## Open Questions

1. **Field naming alternatives**:
   - `merged_ric=100+50+30` (proposed)
   - `ric_sources=100+50+30` (more descriptive?)
   - `merge_ric=100+50+30` (slightly different emphasis?)

2. **Should we validate merged_ric sums to ric?**
   - Add assertion/warning if sum(merged_ric) != ric?
   - Helps catch bugs during development
   - Could be removed in production

3. **Sidecar file priority**:
   - Is this worth implementing now or defer?
   - How many users actually need reconstruction capability?
   - Could be added later without breaking compatibility

4. **Documentation updates needed**:
   - README.md - Header metadata section
   - CLAUDE.md - Field propagation flow
   - CHANGELOG.md - Document the change
   - User guide - Interpretation examples

5. **Version bump**:
   - Minor version (0.4.0) - new feature
   - Patch version (0.3.6) - enhancement to existing functionality
   - Leaning toward minor version

## Related Issues

- Original user report: RiC exceeding --max-sample-size
- Conceptual question: Should --max-sample-size limit apply per-cluster or globally?
- Philosophical: IUPAC codes as "more information" vs "uncertainty"

## Future Enhancements

1. **Per-cluster RiC filtering**: Add `--max-ric-per-source` to fail/warn if any pre-merge ric is too low
2. **Quality-weighted merging**: Instead of simple concatenation, resample proportionally
3. **Consensus re-generation**: Option to regenerate merged consensus from all reads via SPOA
4. **Merge history tracking**: More detailed provenance beyond just ric values

## References

- Initial analysis: Claude Code session 2025-10-20
- User context: Mycology labs using ONT sequencing for community science
- Workflow: specimux → speconsense → speconsense-summarize → MycoMap/GenBank
